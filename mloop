#!/bin/sh

# mloop [-nq1] [folder [command...]] - thin CLI to mblaze(7)

# If invoked with -n, we display only new mail in whatever folder
# we're examining, which by default is your inbox as configured in
# ~/.mblaze/profile or in the envar INBOX.  See the README.md file for
# more on configuration
# If invoked with -q, we skip listing the folder and printing a usage
# summary at start (quiet start)

# You can switch between new/all mail using the new/all commands. 

# The help system is based on hash-plus comments in this script,
# c.f the give_help function, below.
#
# type "brief" at the prompt for a brief usage summary
# type "help" for command summaries on each command
# type "help <cmd>" for more detailed help on <cmd>

SCRIPT=$0

# query config
MBLAZE=${MBLAZE-$HOME/.mblaze}
basedir=$(mhdr -h MaildirBase "$MBLAZE/profile")
basedir=${basedir-$HOME/Maildir}
inbox_name=$(mhdr -h InboxName "$MBLAZE/profile")
[ -z "${inbox_name}" ] && inbox_name=INBOX
inbox=$(mhdr -h Inbox "$MBLAZE/profile")
[ -z "${inbox}" ] && inbox=${basedir}/${inbox_name}
editor_cmd=$(mhdr -h Editor "$MBLAZE/profile")
[ -z "${editor_cmd}" ] && editor_cmd=${EDITOR-${VISUAL-vi}}
EDITOR=${EDITOR-$editor_cmd}
mdopts=$(mhdr -h MdisplayOpts "$MBLAZE/profile")

# parse command-line args
CMD=minbox
quiet_start=$(mhdr -h MloopQuiet "$MBLAZE/profile")
[ -z "${quiet_start}" ] && quiet_start=0
f=
only_one=0
args=$(getopt nq1 $*)
if [ $? -ne 0 ]; then
	echo usage: $(basename $SCRIPT) [-nq1] [folder [cmd...]]
	exit 1
fi
set -- $args
while [ $# -ne 0 ]; do
	case "$1" in
		-1) only_one=1; shift ;;
		-n) CMD=mnewbox; shift; ;;
		-q) quiet_start=1; shift; ;;
		--) shift; break ;;
	esac
done
if [ $# -gt 0 ]; then
	f=$1
	shift
	[ $f = "-" ] && f=""
fi
# set FOLDER and CMD
[ -n "$f" ] && FOLDER=$f
[ -z "${FOLDER}" ] && FOLDER=${INBOX-$inbox_name}
new=
[ "${CMD}" = "mnewbox" ] && new='*'

# common back-end to mcom/mfwd/mrep
tmux_send () {
	typeset cmd args msgno fullcmd title
	cmd=$1
	shift
	case ${cmd} in
		mcom)
			fullcmd="${cmd} $*"
			title="mail: compose"
			;;
		mfwd|mrep)
			args=$(set_args $*)
			msgno=$(tmux show-buffer)
			title="reply"
			[ ${cmd} = mfwd ] && titla="fwd"
			title="${title} ${msgno}"
			fullcmd="${cmd} ${args} -- ${msgno}"
			;;
	esac
	tmux new-window -n "[$title]" "echo ${fullcmd}; env EDITOR=$EDITOR ${fullcmd}; echo '[PRESS RETURN TO CLOSE]'; read"
}

reply () {
	tmux_send mrep $*
}

send () {
	tmux_send mcom $*
}

fwd () {
	tmux_send mfwd $*
}

# rescan current folder and display the current sequence
rescan () {
	typeset nothing afterargs
	nothing=$1
	shift
	afterargs="$*"
	[ -n "${CMD}" ] && {
		if [ ${nothing} = inbox ]; then
			FOLDER=${INBOX-$inbox_name}
		elif [ ${nothing} = open -o ${nothing} = cd ]; then
			[ -z "${afterargs}" ] && afterargs=${INBOX-$inbox_name}
			FOLDER=${afterargs}
		fi
		echo ${CMD} ${FOLDER}
		${CMD} ${FOLDER}
	}
}

# deal with [msgno] [args...]
# if our first arg looks like a number, set msgno/tmux-buffer
# and shift it out.
# return what is left
set_args () {
	typeset the_args
	the_args="$*"
	case ${the_args} in
		[0-9]*)
			set -- ${the_args}
			tmux set-buffer $1
			shift
			the_args="$*"
			;;
	esac
	echo ${the_args}
}

# like set_args but for the extract/mime/show cases msgno can be
# implicit, if first arg is numeric but within the range
# 1..$number_attachments of cur message, don't treat it as a msg#,
# treat it as attachment#
special_args () {
	typeset the_args cur natt
	cur=$(tmux show-buffer)
	the_args="$*"
	case $1 in
		[0-9]*)
			if [ -n "${cur}" ]; then
				natt=$(mshow -t ${cur} |tail -1 | \
					       awk -F: '{print $1}')
				if [ $1 -gt $natt ]; then
					tmux set-buffer $1
					shift
					the_args="$*"
				fi
				# else it is an attachment#, leave args alone
			else
				tmux set-buffer $1
				shift
				the_args="$*"
			fi
			;;
	esac
	echo ${the_args}
}

# search this script for hash-plus comments and display them in various ways
give_help () {
	typeset cmds cmd
	# get the list of commands for starters, alpha-sorted
	cmds=$(grep '#\+' $SCRIPT | \
		       sed -e 's/^.*#\+ //' | awk '{ print $1 }' | sort -u)
	case $1 in
		help)
			# if they give us a specific command find help for it
			# otherwise, dump all the help summaries (first lines)
			if [ -z "$2" ]; then
				for cmd in ${cmds}; do
					grep "#\+ $cmd " $SCRIPT | head -1 | \
						sed -e 's/^.*#\+ //'
				done
			else
				# print all the help for a specific command
				grep "#\+ $2 " $SCRIPT | \
					sed -e 's/^.*#\+ //' | head -1
				grep "#\+ $2 " $SCRIPT | \
					sed -e 1d -e "s/^.*#\+ $2 /    /" | fmt
			fi
			;;
		brief)
			echo "one of:"
			echo ${cmds} | rs
			echo "or: type msg# / select msg# w/mouse in tmux and hit RETURN to see it in new pane"
			;;
	esac
}

usage () {
	echo "usage: $*"
}

# handle one command and optional args
process_command () {
	typeset nothing afterargs beforeargs cmd do_mscan
	nothing=$1
	shift
	afterargs="$*"
	beforeargs=
	cmd="mdisplay ${mdopts}"
	do_mscan=
	case ${nothing} in
		reply|fwd|send) #+ reply [msgno] [mcom-opts] - reply to cur/given msg in new window
			#+ fwd [msgno] [mcom-opts] - forward message
			#+ send [mcom-opts] - send new message, c.f. mcom(1)
			${nothing} ${afterargs}
			return
			;;
		mime|extract|headers) #+ mime [msgno] - display mime structure of msg
			#+ extract [msgno] part# - extract given part of msgno
			#+ extract if no msgno is given and part# is a valid
			#+ extract attachment# for the current message, a
			#+ extract single numeric arg is taken to be att#
			#+ headers [msgno] - dump headers of msg to stdout
			case ${nothing} in
				mime) cmd="mshow -t" ;;
				extract) cmd="mshow -x" ;;
				headers) cmd="mshow -q" ;;
			esac
			afterargs=$(special_args ${afterargs})
			;;
		mv|cp)	#+ mv [msgno] dest-folder - move msg to given folder
			#+ cp [msgno] dest-folder - copy msg to given folder
			cmd=m${nothing}
			afterargs=$(set_args ${afterargs})
			[ -z "${afterargs}" ] && {
				usage "${nothing} [msgno] dest-folder"
				return
			}
			do_mscan=mscan
			;;
		inc) #+ inc [all|new] - incorporate new mail into cur (mark all read in folder)
			#+ inc We use the minc(1) program from mblaze(7) to
			#+ inc incorporate new mail in the current folder,
			#+ inc which many MUAs call mark-all-as-read.
			#+ inc If we were in "new" mode (c.f. the new/all
			#+ inc commands) then we normall switch to "all"
			#+ inc mode after running minc.  If our optional
			#+ inc argument is "new", then we stay in "new" mode
			#+ inc instead.  If our optional argument is "all"
			#+ inc then instead of minc, we run the mincall
			#+ inc script to incorporate all new mail in all
			#+ inc folders.
			if [ -z "${afterargs}" -o "${afterargs}" = new ]; then
				echo minc ${FOLDER}
				minc ${basedir}/${FOLDER} | mscan
				if [ -n "${new}" -a -z "${afterargs}" ]; then
					new=
					CMD=minbox
				elif [ "${afterargs}" = new ]; then
					new='*'
					CMD=mnewbox
				fi
			elif [ "${afterargs}" = all ]; then
				mincall
			else
				usage "inc what?"
			fi
			return
			;;
		decrypt) #+ decrypt [msgno] - run mdecrypt on message
			cmd=mdecrypt
			afterargs=$(set_args ${afterargs})
			;;
		cat) #+ cat [msgno] - dump raw message to stdout
			cmd=mshow
			afterargs=$(set_args ${afterargs})
			;;
		quit) #+ quit - exit program
			exit 0
			;;
		list|ls|open|cd|clear|inbox) #+ list - (re)list current folder
			#+ ls - (re)list current folder
			#+ open folder - switch to different folder
			#+ cd folder - switch to different folder
			#+ clear - re-list current folder
			#+ inbox - switch to in-box and list
			rescan ${nothing} ${afterargs}
			return
			;;
		all) #+ all - switch from new view to all messages in folder
			CMD=minbox
			new=
			rescan ${nothing} ${afterargs}
			return
			;;
		new) #+ new - switch from all messages to only new ones
			CMD=mnewbox
			new='*'
			rescan ${nothing} ${afterargs}
			return
			;;
		spam) #+ spam [msgno] - run message through mrespam
			if [ -n "${afterargs}" ]; then
				echo mrespam ${afterargs}
				mrespam ${afterargs}
				return
			fi
			cmd=mrespam
			;;
		unspam) #+ unspam [msgno] - run message through munspam
			if [ -n "${afterargs}" ]; then
				echo munspam ${afterargs}
				munspam ${afterargs}
				return
			fi
			cmd=munspam
			;;
		grep) #+ grep args... - run magrep args on current folder
			magrep ${afterargs} | mthread | mscan
			return
			;;
		restrict) #+ restrict args - run magrep and set results as current seq
			magrep ${afterargs} | mthread | mseq -S | mscan
			return
			;;
		dirs) #+ dirs - list Maildirs with new mail in them
			mnewdirs | rs
			return
			;;
		help|brief) #+ help - list commands and what they do
			#+ brief - print a brief usage summary/command list
			give_help ${nothing} ${afterargs}
			return
			;;
		[0-9]*) tmux set-buffer ${nothing} ;;

		[a-z]*)
			usage "not recognized: ${nothing}"
			give_help brief
			return
			;;
	esac
	msgno=$(tmux show-buffer)
	if [ -n "${msgno}" ]; then
		f=$(mpick ${msgno} 2>/dev/null)
		if [ -n $f ]; then
			echo ${cmd} ${beforeargs} ${msgno} ${afterargs}
			if [ -n "${do_mscan}" ]; then
				${cmd} ${beforeargs} ${msgno} ${afterargs} | \
					${do_mscan}
			else
				${cmd} ${beforeargs} ${msgno} ${afterargs}
			fi
		fi
	fi
}

msgno=
if [ $quiet_start -eq 0 ]; then
	${CMD} ${FOLDER}
	echo folder: ${FOLDER}, cmd: ${CMD}, editor: ${EDITOR}
	give_help brief
fi
if [ $# -gt 0 ]; then
	process_command $*
	[ $only_one -ne 0 ] && exit 0
fi
while read nothing?"${FOLDER}${new}> " afterargs; do
	[ -n "${nothing}" ] && process_command ${nothing} ${afterargs}
done
