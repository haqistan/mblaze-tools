#!/bin/sh

# mloop [-n] [folder] - thin CLI to mblaze(7)

# If invoked with -n, we display only new mail in whatever folder
# we're examining, which by default is your inbox as configured in
# ~/.mblaze/profile or in the envar INBOX.  See the README.md file for
# more on configuration

# You can switch between new/all mail using the new/all commands. 

# type "brief" at the prompt for a brief usage summary
# type "help" for more detailed help.

SCRIPT=$0

MBLAZE=${MBLAZE-$HOME/.mblaze}
basedir=$(mhdr -h MaildirBase "$MBLAZE/profile")
basedir=${basedir-$HOME/Maildir}
inbox_name=$(mhdr -h InboxName "$MBLAZE/profile")
[ -z "${inbox_name}" ] && inbox_name=INBOX
inbox=$(mhdr -h Inbox "$MBLAZE/profile")
[ -z "${inbox}" ] && inbox=${basedir}/${inbox_name}
editor_cmd=$(mhdr -h Editor "$MBLAZE/profile")
[ -z "${editor_cmd}" ] && editor_cmd=${EDITOR-${VISUAL-vi}}
EDITOR=${EDITOR-$editor_cmd}
mdopts=$(mhdr -h MdisplayOpts "$MBLAZE/profile")

CMD=minbox
f=
while [ $# -gt 0 ]; do
	case $1 in
		-n) CMD=mnewbox ;;
		*)
			if [ -z "${f}" ]; then
				f=$1
			else
				echo usage: $(basename $SCRIPT) [-n] [folder]
				exit 1
			fi
			;;
	esac
	shift
done
[ -n "$f" ] && FOLDER=$f
[ -z "${FOLDER}" ] && FOLDER=${INBOX-$inbox_name}
new=
[ "${CMD}" = "mnewbox" ] && new='*'

# common back-end to mcom/mfwd/mrep
tmux_send () {
	typeset cmd args msgno fullcmd title
	cmd=$1
	shift
	case ${cmd} in
		mcom)
			fullcmd="${cmd} $*"
			title="mail: compose"
			;;
		mfwd|mrep)
			args=$(set_args $*)
			msgno=$(tmux show-buffer)
			title="reply"
			[ ${cmd} = mfwd ] && titla="fwd"
			title="${title} ${msgno}"
			fullcmd="${cmd} ${args} -- ${msgno}"
			;;
	esac
	tmux new-window -n "[$title]" "echo ${fullcmd}; env EDITOR=$EDITOR ${fullcmd}; wait_for_me"
}

reply () {
	tmux_send mrep $*
}

send () {
	tmux_send mcom $*
}

fwd () {
	tmux_send mfwd $*
}

# rescan current folder and display the current sequence
rescan () {
	typeset nothing afterargs
	nothing=$1
	shift
	afterargs="$*"
	[ -n "${CMD}" ] && {
		if [ ${nothing} = inbox ]; then
			FOLDER=${INBOX-$inbox_name}
		elif [ ${nothing} = open -o ${nothing} = cd ]; then
			[ -z "${afterargs}" ] && afterargs=${INBOX-$inbox_name}
			FOLDER=${afterargs}
		fi
		echo ${CMD} ${FOLDER}
		${CMD} ${FOLDER}
	}
}

# deal with [msgno] [args...]
# if our first arg looks like a number, set msgno/tmux-buffer
# and shift it out.
# return what is left
set_args () {
	typeset the_args
	the_args="$*"
	case ${the_args} in
		[0-9]*)
			set -- ${the_args}
			tmux set-buffer $1
			shift
			the_args="$*"
			;;
	esac
	echo ${the_args}
}

# search this script for hash-plus comments and display them
give_help () {
	case $1 in
		help)
			if [ -z "$2" ]; then
				grep '#\+' $SCRIPT | sed -e 's/^.*#\+ //'
			else
				grep "#\+ $2" $SCRIPT | sed -e 's/^.*#\+ //'
			fi
			;;
		brief)
			typeset cmds
			cmds="$(grep '#\+' $SCRIPT | sed -e 's/^.*#\+ //' | awk '{ print $1 }' | sort)"
			echo "one of:"
			echo $cmds | rs
			echo "or: type msg# / select msg# w/mouse in tmux and hit RETURN to see it in new pane"
			;;
	esac
}

usage () {
	echo "usage: $*"
}

# handle one command and optional args
process_command () {
	typeset nothing afterargs cmd do_mscan
	nothing=$1
	shift
	afterargs="$*"
	cmd="mdisplay ${mdopts}"
	do_mscan=
	case ${nothing} in
		reply|fwd|send) #+ reply [msgno] [mcom-opts] - reply to cur/given msg in new window
			#+ fwd [msgno] [mcom-opts] - forward message
			#+ send [mcom-opts] - send new message, c.f. mcom(1)
			${nothing} ${afterargs}
			return
			;;
		mime|extract|headers) #+ mime [msgno] - display mime structure of msg
			#+ extract msgno part - extract given part of msgno
			#+ headers [msgno] - dump headers of msg to stdout
			case ${nothing} in
				mime) cmd="mshow -t" ;;
				extract) cmd="mshow -x" ;;
				headers) cmd="mshow -q" ;;
			esac
			afterargs=$(set_args ${afterargs})
			;;
		mv|cp)	#+ mv [msgno] dest-folder - move msg to given folder
			#+ cp [msgno] dest-folder - copy msg to given folder
			cmd=m${nothing}
			afterargs=$(set_args ${afterargs})
			[ -z "${afterargs}" ] && {
				usage "${nothing} [msgno] dest-folder"
				return
			}
			do_mscan=mscan
			;;
		inc) #+ inc [all] - incorporate new mail into cur (mark all read in folder)
			if [ -z "${afterargs}" ]; then
				echo minc ${FOLDER}
				minc ${basedir}/${FOLDER} | mscan
				[ -n "${new}" ] && {
					new=
					CMD=minbox
				}
			elif [ "${afterargs}" = all ]; then
				mincall
			else
				usage "inc what?"
			fi
			return
			;;
		decrypt) #+ decrypt [msgno] - run mdecrypt on message
			cmd=mdecrypt
			afterargs=$(set_args ${afterargs})
			;;
		cat) #+ cat [msgno] - dump raw message to stdout
			cmd=mshow
			afterargs=$(set_args ${afterargs})
			;;
		quit|exit) #+ quit - exit program
			exit 0
			;;
		list|open|cd|clear|inbox) #+ list - (re)list current folder
			#+ open folder - switch to different folder
			#+ cd folder - switch to different folder
			#+ clear - re-list current folder
			#+ inbox - switch to in-box and list
			rescan ${nothing} ${afterargs}
			return
			;;
		all) #+ all - switch from new view to all messages in folder
			CMD=minbox
			new=
			rescan ${nothing} ${afterargs}
			return
			;;
		new) #+ new - switch from all messages to only new ones
			CMD=mnewbox
			new='*'
			rescan ${nothing} ${afterargs}
			return
			;;
		spam) #+ spam [msgno] - run message through mrespam
			if [ -n "${afterargs}" ]; then
				echo mrespam ${afterargs}
				mrespam ${afterargs}
				return
			fi
			cmd=mrespam
			;;
		unspam) #+ unspam [msgno] - run message through munspam
			if [ -n "${afterargs}" ]; then
				echo munspam ${afterargs}
				munspam ${afterargs}
				return
			fi
			cmd=munspam
			;;
		grep) #+ grep args... - run magrep args on current folder
			magrep ${afterargs} | mthread | mscan
			return
			;;
		restrict) #+ restrict args - run magrep and set results as current seq
			magrep ${afterargs} | mthread | mseq -S | mscan
			return
			;;
		dirs) #+ dirs - list Maildirs with new mail in them
			mnewdirs | rs
			return
			;;
		help|brief) #+ help - list commands and what they do
			#+ brief - print a brief usage summary/command list
			give_help ${nothing} ${afterargs}
			return
			;;
		[0-9]*) tmux set-buffer ${nothing} ;;

		[a-z]*)
			usage "not recognized: ${nothing}"
			give_help brief
			return
			;;
	esac
	msgno=$(tmux show-buffer)
	if [ -n "${msgno}" ]; then
		f=$(mpick ${msgno} 2>/dev/null)
		if [ -n $f ]; then
			echo ${cmd} ${msgno} ${afterargs}
			if [ -n "${do_mscan}" ]; then
				${cmd} ${msgno} ${afterargs} | ${do_mscan}
			else
				${cmd} ${msgno} ${afterargs}
			fi
		fi
	fi
}

msgno=
${CMD} ${FOLDER}
echo folder: ${FOLDER}, cmd: ${CMD}, editor: ${EDITOR}
give_help brief
while read nothing?"${FOLDER}${new}> " afterargs; do
	[ -n "${nothing}" ] && process_command ${nothing} ${afterargs}
done
